# PHP Study Repository
PHP勉強用のリポジトリです。基本的な制御構文から始めてオブジェクト指向プログラミングまである程度書けるようになるまでの勉強資料です。

ここに書かれていることができるようになったからと言ってPHPでバリバリ開発ができるようになるわけではありません。バリバリ開発できるようになるためのスタートアップの勉強資料と捉えてください。

間違いやより良い書き方があれば是非教えてください:)

## 対象

* 始めてプログラムを勉強する方
* ちょっとPHP触ったけどわけわかんなくて止めてた方
* 私の知り合いの何人か

## 留意事項

* この資料を作成する際に使用しているPHPのバージョンは7.1.7です。
* PHP5系や4系では若干挙動が異なる可能性があります。
* 拡張モジュールは入れていません。
* Webサーバはビルドインサーバを利用します。
* PHPのインストール方法（環境構築）については説明しません。

## Section1 - 変数と型

このセクションでは変数と型について説明をしていきます。まずは変数から始めて行きましょう。何も難しいことはありません。肩の力を抜いてPHPを始めましょう :)

### 変数

Branch：[section1-1](https://github.com/yoshida-san/php-study/tree/section1-1 "section1-1")

少し調べてみるとわかるのですが、変数とは嫌になるぐらい目に入る「値を入れる箱」のことです。この説明で「なるほど、わかったよ:)」となる方はこのステップを飛ばしても大丈夫でしょう（PHPのルールが少し書いてあるので最後の方だけは見た方が良いかもしれないね）。少なくとも私は変数がわからない状態で「値を入れる箱」と言われて理解はできませんでした:(

言葉で理解するより実際にイメージしやすい形に落としてみましょう。

それでは、ここで1つ問題です。

x + 1 = 3の場合、xには何が入るでしょうか？

答えは2ですね。別に馬鹿にしているわけではありませんよ:)

続いての問題は、

x = 3とした場合、x + 2の答えは何でしょうか？

答えはわかりますか？答えは5です。x = 3（xが3であること）が前提となるわけですね。その前提の上で2を加算して5になるわけです。

変数というのは、このx = 3の部分のxのことを指します。ポイントは、「xにはこういう値（数字や文字）が入る（または入れる）」という部分です。値を入れるから箱という表現が多く使われるわけですね。実際にコードベースで見てみましょう。[section1-1](https://github.com/yoshida-san/php-study/tree/section1-1 "section1-1")というブランチで確認していきましょう。

```php:index.php
<?php

// aという名前の変数に3という数値を入れる
$a = 3;

// bという名前の変数に"変数だよ"という文字列を入れる
$b = "変数だよ";

// cという名前の変数に5+6をいう計算式の結果を入れる
$c = 5 + 6;

// 値（数値や文字列）を入れないdという名前の変数を用意だけしておく
$d;

// 用意してあるdという名前の変数に5という数値を入れる
$d = 5;

// 用意してあるdという名前の変数を9という数値で上書きする
$d = 9;

?>
```

動かしてみたい気持ちもあると思いますが、今は動かしても何ともならないので動かすのはもう少し後にしましょう:)

先に出てきたx = 3に似ているところがありますね。PHPの場合、変数名の前に$（ドルマーク）を付けるルールがあります。例えばnameという変数を作りたければ$nameとする必要があります。「$は何となく嫌だから#にしたい」という気持ちがわいてきても我慢して$を使いましょう。

変数は「箱」というのは何となくイメージが沸いたでしょうか？ただやっぱりわかりづらいですよね。パソコンの中にファイルを作りそのファイルの中身を書いたり消したり書き換えたりする、という方がイメージしやすいかもしれませんね:)

え？最初と最後の変なコードは何かって？説明が抜けていましたね。最初と最後の2行は「この間に書かれた内容はPHPのプログラムコードだよ」という意味があります。この間以外にプログラムコードを書いてもそれば残念ながらPHPのコードとは認識されません。

```php

// ここはPHPのプログラムコードとして認識されない

<?php
// ここはPHPのプログラムコードとして認識される
?>

// ここはPHPのプログラムコードとして認識されない

<?php
// ここはPHPのプログラムコードとして認識される
?>

```

えっ？えっ？まだわからないことがある？ちょいちょい;(セミコロン)が付いてる？よく見つけたね。それは処理の区切りを示す記号です。「変数を用意する」という処理、「変数を用意して値を入れる」という処理、それぞれの処理の区切りを;(セミコロン)で表しているわけですね。何か処理を書いたら;(セミコロン)を付ける、今はそう覚えておきましょう:)

よく見ると文字列を入れる時は"（ダブルクォーテーション）が付いていて数値を入れる時は何も付いていないですね。これは数値と文字という違いからくるものになります。これについては次の「型」で説明していきます。

### 型

Branch：[section1-2](https://github.com/yoshida-san/php-study/tree/section1-2 "section1-2")

変数は何となくわかりましたか？何となくで構いません。まずは全体のイメージを掴んでいきましょう。続いては「型」について少し覚えていきましょう:)

先程変数で「変数はパソコンの中にあるファイルのようなイメージ」と説明しましたが、ファイルには複数の種類があります。Microsoft Excelだったりテキストファイルだったり様々な種類がありますね。ExcelならExcelの書き方やデータがありますし、テキストファイルにはテキストファイルの書き方やデータがあります。テキストファイルに無理やり表を作っても良いのですが、Excelみたいな便利機能は付与できませんよね:(

プログラムの変数にも同じように種類が存在します。この種類のことをプログラムでは「型」と呼びます。PHPで使われる型はたくさんの種類がありますが、よく使われる型は以下の通りです。この他にも型はありますので、興味があったら調べてみてください:)

| 型名称（英字）  | 型名称（日本語） | 設定可能な値の例（/で区切り） |
|:--------------|:--------------|:-------------|
| [integer](http://php.net/manual/ja/language.types.integer.php "integer") | 整数型 | 0 / 123 |
| [float（double)](http://php.net/manual/ja/language.types.float.php "float（double)") | 浮動少数点型 | 0.001 / 3.14 |
| [string](http://php.net/manual/ja/language.types.string.php "string") | 文字列型 | Hello world / ぴーえいちぴー |
| [boolean](http://php.net/manual/ja/language.types.boolean.php "boolean") | 論理型 | true / false  |

細かいことは置いといて早速コードベースで見てみましょう:)

```php:index.php
<?php

// 整数型
$int = 123;

// 浮動小数点数型
$flt = 3.14;

// 文字列型
$str = "Hello world";

// 論理型
$bln = true;

?>
```

そうです！実は変数の時に整数型と文字列型を使っていたのです！

整数を変数に入れたら整数型、文字列を入れたら文字列型になるわけですね:) 変数自体に型があるのではなく、入れた値によって型が決定される形になります。変数のところで出てこなかった浮動小数点と論理型について少し掘り下げていきましょう。

#### 浮動小数点型

こちらは小数点を持つ数値を変数に代入した場合に決定される型になります。そんな難しくはありませんね:)

#### 論理型

論理型は非常にシンプルです。他の型は相当数のケースの値が入ることが予想されます。例えば文字列であればかなりの組み合わせが存在します。数値も然りですね。ところが論理型に関しては2パターンしかないのです。論理型に入る値は「true（真）」と「false（偽）」になります。「正しい」か「正しくない」かが入ります。これだけだと一体いつ使うのだろう...と思ってしまいますね。使いどころはこの後にたくさん出てくるので安心してください:)

## Section2 - 配列

変数と型についてはもう大丈夫かな？文字列型の変数に「今日はいい天気ですね」って代入してって言われたらできるかな:)

続いて配列というものを覚えていこう。実はこの配列も一つの型なんだ。マップと呼ばれるんだけど、この話はあなたがPHPを好きになったら調べてみて。

このセクションで配列というのが何なのか覚えていこう。配列には「配列」と「連想配列」という2つの種類があるんだ。大体似たようなものなんだけど種類があれば違いがある、その違いについても覚えていこう。

難しそう？そんなに身構えないでいいよ、時間は無いようで以外にあるものなんだ、ゆっくり覚えていこう:)

### 配列

Branch：[section2-1](https://github.com/yoshida-san/php-study/tree/section2-1 "section2-1")

配列というのを簡単に説明すると「値が連なって1つになったもの」という感じかな。少しわかりづらいかもしれないね。さっき「変数はパソコンの中にあるファイル」と説明したのを覚えているかな。変数が「ファイルそのもの」としたら配列は「フォルダ」と覚えると良いよ:) 1つのフォルダには複数のファイルを入れることができるよね。配列も同じで1つの配列の中に複数の変数を入れることができるという感じかな。実際は配列に入るものは「変数」ではなく「値そのもの」なんだけどね。もうわかっていると思うけれど変数には必ず名前が必要なんだ、$nameみたいにね。

値が連なったものって言うと「123Hellotrue」みたいなものをイメージしたかもしれないけど123Hellotrueだとどこが値の区切りかわからないよね。この問題を解決してくれるのが配列なんだ。例えば君がAからZまでの文字を変数として用意しておきたいと思ったとしよう。これを変数で実装すると次の形になるね。

```php
<?php
$a = "a";
$b = "b";
$c = "c";
$d = "d";
$e = "e";
$f = "f";
$g = "g";
$h = "h";
$i = "i";
$j = "j";
$k = "k";
$l = "l";
$m = "m";
$n = "n";
$o = "o";
$p = "p";
$q = "q";
$r = "r";
$s = "s";
$t = "t";
$u = "u";
$v = "v";
$w = "w";
$x = "x";
$y = "y";
$z = "z";
?>
```

とても長いね:( これを配列で表すとこうなるよ。

```php
<?php
$ary = array("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z");
?>
```

これはこれで横に長いね:( 変数の説明の時に書いたんだけど処理の終わりに;（セミコロン）を付けるって言ったのを覚えているかな。長くて見辛いコードは改行して見やすくすることができるんだ:) 少し見やすくしてみようか。

```php
<?php
$ary = array(
             "a", "b", "c", "d", "e",
             "f", "g", "h", "i", "j",
             "k", "l", "m", "n", "o",
             "p", "q", "r", "s", "t",
             "u", "v", "w", "x", "y", "z"
            );
?>
```

どうだろう、少しは見やすくなったんじゃないかな。

それじゃあ、さっきのフォルダの例で配列を説明していくよ。コードを見て何となくわかると思うんだけど$aryというのが配列型変数の名前だね。数値や文字列はそのまま変数に入れることができたけど今回は値の部分にarrayという単語が付いているね。これは配列そのものを表すために必要なものなんだ、ファイルを格納するフォルダを作るようなイメージだね。フォルダを作る場合、単純に作るだけではなくてフォルダに名前が必要になる、「フォルダの名前が変数名」「フォルダそのものがarray()」と覚えると覚えやすいと思うよ:)

配列のイメージがある程度掴めてきたかな。続いて配列の書き方について説明していくよ。まず下のコードを見て欲しい。

```php
$ary = array();
```

これはさっき書いたコードからa〜zを削除しただけなんだけど、このコードの意味はわかるかな？

そうだね、この段階ではフォルダを作成してそのフォルダに名前を付けただの状態なんだ。フォルダはあるけど中身は空っぽ。それじゃ意味がないからこの空っぽの配列に値を入れてみよう。

```php
$ary = array(1, 2, 3);
```

もう気が付いていると思うんだけど、値の間に,（カンマ）があるね。これは値の区切りに使われるんだ。処理の区切りは;（セミコロン）、値の区切りは,（カンマ）と覚えておこう。さっきから「フォルダの中にあるファイルのイメージ」と言って説明してきたけどこの例えは正しくは無いんだ。理解しやすいと思うけど正しくはないんだよね。

わかりやすく正しい例に近いのはモーテルかな。モーテルには部屋番号があって、その部屋に何かが置いてある。何が置いてあるかは部屋のランクやモーテルによって違う。配列もそんな感じなんだ。配列自体にランクがあるわけでは無いんだけどね。配列ではこの「部屋番号」というのがとても重要なファクターになるから覚えておこう。

配列の作り方はわかったけど配列の中にセットした値を参照する時はどうしたら良いんだろう？そう思うよね。数値型や文字列型の場合は値が1つだから「変数＝そのままの値」の式が成り立つんだ。ただ配列の場合は少し事情が違う。配列は値を複数持てるというのはもうわかってるよね。では、その値を使いたい場合、どういう風に参照するのかを覚えていこう。

ここではechoという処理を使っていくよ。echoは数値や文字列を出力する処理のこと、はじめて出力するプログラムを書いていこう:)

```php
<?php
// echoは数値や文字を出力する処理だよ
$str = "今日はいい天気だね";  // 変数に文字列を代入
echo $str;                 // 変数の値を出力

// 配列を用意
$ary = array(1, 2, 3);

// 配列の0番目の要素を出力
echo $ary[0];
?>
```

文字列の値出力と配列の値出力で少し違うところがあるんだ。配列の方で[0]が付いているね。この[0]がさっき言った重要なファクター「部屋番号」なんだ。配列は値を複数持てることはもうわかってると思うんだけど、その値を取り出す方法は他の変数とはちょっと違うんだよ。配列の中身は複数あって、そのどれを欲しいか指定する必要があるんだ。これがさっき言っていた「部屋番号」そのものなんだ。配列的には部屋番号ではなくて「要素番号」って呼ぶんだ、これは覚えておいた方がいい。要素番号は0から始まり1ずつ増えていく整数というのも覚えておいた方がいいね、PHPは0だけど他のプログラミング言語では1からの場合もあるんだ。

```php
<?php
// 配列を用意
// 要素番号0：おはよう
// 要素番号1：こんにちわ
// 要素番号2：こんばんわ
// 要素番号3：おやすみ
$ary = array("おはよう", "こんにちわ", "こんばんわ", "おやすみ");

// 配列からおはようを取り出して出力する
echo $ary[0];

// 配列からこんにちわを取り出して出力する
echo $ary[1];

// 配列からこんばんわを取り出して出力する
echo $ary[2];

// 配列からおやすみを取り出して出力する
echo $ary[3];
?>
```

最後にもう1つ覚えることがあるんだ。配列は値を複数持てるのと同時に複数の型を内包することができるんだ。言葉だとよくわからないかもしれないからコードを書いてみるね。

```php
<?php
// 配列に数値、文字列、論理、配列を入れる
$ary = array(123, "こんにちわ", true, array(1, "Hello", false));
?>
```

そうなんだ、配列の中には型を限定せずに配列すら入れることができるんだ。この辺りは追々覚えていこう。まずは「配列は複数の値を持つことができる」「要素番号（部屋番号）は0から始まる整数」これを覚えておこう。

### 連想配列

Branch：[section2-2](https://github.com/yoshida-san/php-study/tree/section2-2 "section2-2")

連想配列もそお名前の通り配列そのものなんだ。基本的には配列と同じなんだけど少し違いがある。それは「部屋番号」を自分で決めることができるんだ。部屋番号ではなく「部屋名」を自分で決めることができるんだ。注意点としては同じ部屋名は付けられないということ。それは同じ部屋に複数の値は入れられないということなんだ。同じ部屋に値を入れようとするとその値は上書きされてしまうんだ。これは配列も同じなんだ。連想配列をコードで書いてみよう。

```php
$ary = array(
             "name" => "John Smith",
             "age" => 24
            );
```

配列は要素番号を自動的に割り当てられるけれど連想配列はその名前の通り、要素名（さっき言った部屋名のことだね）からそこにある値を連想できるようになってるわけだね。書き方は上のコードの通り、値だけではなく要素名もセットしてあげる必要があるんだ。逆に言えばそれ以外は配列と同じだからあまり難しく捉えないで欲しい:) それは値を参照する時も同じ。さっそく連想配列の値を参照してみよう。

```php
<?php
$ary = array(
             "name" => "John Smith",
             "age" => 24
            );

echo $ary["name"];
?>
```

配列は要素番号（部屋番号のことだね）を指定したけど連想配列では要素名を指定するんだ。これも配列との違いなんだけど配列がわかっていれば理解するのはそう難しくはないよね。

## Section3 - 条件文(if, switch)と比較演算子

ここまではあまりプログラミングをしている感じはあまり無かったかもしれないね。これからはみんなが思うプログラミングになると思うよ。まずはプログラミングの基本中の基本の1つ「条件文」を覚えていこう。条件文を使わないプログラムはほとんど無いからしっかり覚えていこう:) 次の繰り返し文でも同じことを言うと思うけどね。

### if

Branch：[section3-1](https://github.com/yoshida-san/php-study/tree/section3-1 "section3-1")

ifを翻訳すると「もし、xxxxなら」のもしだね。プログラムのifもこれと同じなんだ。プログラムの場合は、「もしxxxがzzzなら」という形になるよ。例えば「もし君が元気なら」とか「もし会社に遅刻しそうなら」とか、こんな感じ。「もしxxxがzzzなら」で終わってしまっては意味が無いからその後に続くものがあるんだ。「もしxxxがzzzならnnnnnするよ」という形になる。これが条件分の基本形になるよ。固い感じで言うと「とあるものが予測される結果であった場合、とある処理を行う」って感じかな。実際にコードで見てみよう。気が付いているかもしれないし気が付いていないかもしれないけど、もう僕と君はコードで話し合えるんだ。まだ簡単なことしか話し合えていない？そんなこと些細なことだよ。コードで話し合えるということは実に素晴らしいことなんだ:)

```php
<?php
// ここは説明しないよ
$name = "John Smith";

// もし名前がJohn Smithなら
if ($name == "John Smith") {
    // 自己紹介をするよ
    echo "I'm John Smith :)";
}
?>
```

何となくイメージはついたかな？if文をよりわかりやすくしてみるよ。

```php
<?php
// もしxxxxがzzzzなら
if (xxxx == zzzz) {
    // nnnnするよ
    nnnn;
}
?>
```

初めて見るものがあって戸惑うかもしれないけれどこれからもっとたくさん見たこと無いものに触れていくことになると思う。戸惑うよりワクワク楽しめるようになれたらいいね:) ひとつずつ説明していくよ。

まずは「if (xxxx == zzzz) 」について説明するね。これは見てわかると思うんだけど「もしxxxxがzzzzだったら」の部分になるんだ。==は比較演算子と言って、「同じだったら」「同じじゃなかったら」「以上だったら」「以下だったら」「より大きかったら」「より小さかったら」等々、色々な比較ができるんだ。先のコードで言えば「$nameの値が"John Smith"と同じだったら」となるわけだね。比較演算子については別でちゃんと説明するから今は「比較演算子というやつを使って比較するんだ」と覚えておいて欲しい。

続いて{}の説明をするよ。これはすごくシンプルで「nnnnする」の「範囲」になるんだ。範囲って何だ？ってなると思うけど条件に合致した時に1つの処理だけではなく複数の処理をしたい場合もあると思うんだ。そういう時に「ここからここまでは条件に合致した時に行う処理だよ」というのを明確にしてあげるために必要になるんだよ。例えば次のようになるね。

```php
<?php
// ここは説明しないよ
$name = "John Smith";

// もし名前がJohn Smithなら
if ($name == "John Smith") {
    // 自己紹介をするよ
    echo "I'm John Smith :)";
    echo "I like football !!";
}
?>
```

こんな感じだね。「echo "I'm John Smith :) I like football !!";」と書けば良いじゃないか！と思った人もいると思う。それは実に素晴らしい考えだよ:) ただ、今回はあくまでひとつの例として書いているんだ、許して欲しい。もっと良い例はたくさんあると思う。良い例が思い付いたら教えてくれると嬉しいよ:)

先の例だと「条件に一致した場合に処理をする」という形だったね、条件に一致した場合はAという処理を行って条件に一致しなかった場合はBという処理をする場合を考えてみよう。==は一致するという意味だったね。一致しないというのは!=で表すんだ。と、いうことは...

```php
// ここは説明しないよ
$name = "John Smith";

// もし名前がJohn Smithなら
if ($name == "John Smith") {
    // 自己紹介をするよ
    echo "I'm John Smith :)";
}

if ($name != "John Smith") {
    // John Smithじゃないよ...
    echo "I'm not John Smith :(";
}
```

こうなるね。こう書いてもプログラムは動くのだけれど別の書き方もあるんだ。elseといって条件に合致しない場合、という意味があるんだよ。先のコードをelseで書き直してみるよ。

```php
// ここは説明しないよ
$name = "John Smith";

// もし名前がJohn Smithなら
if ($name == "John Smith") {
    // 自己紹介をするよ
    echo "I'm John Smith :)";
} else {
    // John Smithじゃないよ...
    echo "I'm not John Smith :(";
}
```

こうなるよ。少し長々書いてしまったけど覚えて欲しいことは「ifで条件判定ができる」「比較演算子で色々な比較ができる」「条件に一致しなかった場合の処理はelseでひとまとめにできる」の3つだよ。

else ifというものもあるけどここで説明はしないでおくよ、興味があったら調べて見て欲しい。ここまでの内容が理解できていればスムーズに理解できると思うよ:)

### switch

Branch：[section3-2](https://github.com/yoshida-san/php-study/tree/section3-2 "section3-2")

条件文はifだけじゃないんだ、実はswitchという構文でも条件分岐ができるんだよ。まずはコードを見てみよう。

```php
// ここは説明しないよ
$number = 1;

// 
switch ($number) {
    case 0:
        echo "$numberは0に等しい";
        break;
    case 1:
        echo "$numberは1に等しい";
        break;
    case 2:
        echo "$numberは2に等しい";
        break;
    default:
       echo "$numberは0,1,2に等しくない";
}
```

何となく見ればわかると思うんだ。少し説明をしていくね。

構文はifと違うけれど比較するという点は同じなんだ。「switch ($number)」でどの値を比較対象とするかを設定しているんだ。ここで言えば$numberの値を比較する、という感じだね。

「case x:」はswitchで指定した値と同値だった場合に処理される部分だよ。つまりcase x:のxと先の$numberが同じであればcase下の処理が実行されるわけだね。ここで注意しなければならないのはifとは違いbreakが必要なことなんだ。先の例だとまず$numberと0を比較して一致しないから次に1と比較をして一致をするからechoを実行するわけだね。ここでbreakを実行すると次の2と比較する処理以降は実行されないんだ。逆に言えばbreakをしなければその後の2との比較やdefaultの処理が実施されるんだ。

最後にdefaultの説明をするね。defaultはifで出てきたelseと同じでいくつかの条件に合致しなかった場合に処理される部分になるよ。defaultはcaseの最後に書くからbreakは不要なんだ。

### 比較演算子

Branch：[section3-3](https://github.com/yoshida-san/php-study/tree/section3-3 "section3-3")

ifの説明の時に少し書いたけど値を比較と言ってもたくさんの種類があるんだ。同じ、異なる、以上、より大きい、以下、より小さい、少なくともこれぐらいは覚えておく必要はある。ただルールがわかればそう難しくないよ:) まずは一覧で確認していこう。この一覧は[PHPの公式リファレンス](http://php.net/manual/ja/language.operators.comparison.php "PHPの公式リファレンス")でも確認できるよ。

| 例 | 名前 | 結果 |
|:--------------|:--------------|:-------------|
| $a == $b | 等しい | 型の相互変換をした後で $a が $b に等しい時に TRUE |
| $a === $b | 等しい | $a が $b に等しく、および同じ型である場合に TRUE |
| $a != $b | 等しくない | 型の相互変換をした後で $a が $b に等しくない場合に TRUE |
| $a <> $b | 等しくない | 型の相互変換をした後で $a が $b に等しくない場合に TRUE |
| $a !== $b | 等しくない | $a が $b と等しくないか、同じ型でない場合に TRUE |
| $a < $b | より少ない | $a が $b より少ない時に TRUE |
| $a > $b | より多い | $a が $b より多い時に TRUE |
| $a <= $b | より少ないか等しい | $a が $b より少ないか等しい時に TRUE |
| $a >= $b | より多いか等しい | $a が $b より多いか等しい時に TRUE |

ifやswitchでは「xxxxがzzzzであれば」と説明したけれど、上の表では「TRUE」と表記されているね。これは条件式の結果を意味するものなんだ。条件式とはifのところで書いた「$name == "John Smith"」の部分のこと。ifやswitchは条件式の結果を見て処理を行うか行わないかを見ている、と言えるね。

あまり難しくないと思うけど「型の相互変換」という言葉は見慣れないね。この部分について説明していくよ。型の相互互換というのは最初に説明した型を自動的に変換してくれる、というものなんだ。例えば==で文字列の"1"と数値の1と比較するとTRUE（同じと判定される）になるけれど、===を使って文字列の"1"と数値の1と比較するとFALSE（等しくない）と判定されるんだ。この違いは型の相互変換を行うか行わないかの違いなんだ。==や!=の場合は自動的に型を同じに変換して比較を行い、===や!==の場合は型の含めて同値か比較をする形になる。例を上げてみよう。

```php
<?php

// trueになるよ
if(1 == "1") {
    echo "true!";
} else {

    echo "false...";
}

// falseになるよ
if(1 === "1") {
    echo "true!";
} else {

    echo "false...";
}

// falseになるよ
if(1 != "1") {
    echo "true!";
} else {

    echo "false...";
}

// trueになるよ
if(1 !== "1") {
    echo "true!";
} else {

    echo "false...";
}

// trueになるよ
if(1 == true) {
    echo "true!";
} else {

    echo "false...";
}

// falseになるよ
if(1 === true) {
    echo "true!";
} else {

    echo "false...";
}

// trueになるよ
if("true" == true) {
    echo "true!";
} else {

    echo "false...";
}

// falseになるよ
if("true" === true) {
    echo "true!";
} else {

    echo "false...";
}
?>
```

このコードと結果から型の変換を行う場合は値が同じであればtrueになることがわかるね。それでもいくつか不思議なことがあると思うんだ。bool値の型変換は不思議な感じがしないかい？少なくとも僕は最初不思議な感じがしたんだ。1でも"1"でも"true"でも同じって不思議な感じがするよね。これが型の相互変換なんだ。便利な半面、意図しない動きや判定になってしまう可能性があることは頭の中に入れておいた方がいいね。可能な限り===や!==を使うべきだとは思っているよ。

これは補足なんだけど==や!=は等価演算子と呼ばれて===や!===は厳密等価演算子と呼ばれることが多いんだ。これは覚えておくといいと思う。

## Section4 - 繰り返し文

繰り返し文はそのままの意味で同じ処理を繰り返す時に利用される制御構造なんだ。制御構造というと難しいイメージがあるかもしれないけれど、if文やswitch文のようなテンプレートがあるからそこまで身構えなくてもいいよ。繰り返し文を使わないプログラムはほとんど無いからしっかり覚えていこう（どこかで言ったような一言な気がする）。

### for

Branch：[section4-1](https://github.com/yoshida-san/php-study/tree/section4-1 "section4-1")

早速コードを見てみよう。

```php
<?php

// for文の基本的なパターン
for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

// for文でもbreakができるんだ！
for ($i = 1; $i <= 10; $i++) {
    if ($i > 5) {
        break;
    }
    echo $i;
}
?>
```

何となくfor (何かの式) { 処理 }となっていることに気付いたかな。それが気付きというやつなんだ、プログラミングの世界だけじゃないけどとても大事なことなんだ。インスピレーションやアハ体験？のようなものでそれは学習や人生を楽しく、より豊かにするものであり、君をより素晴らしい人にしてくれる小さいけれど貴重な体験なんだ。話がそれてしまったね。for文に戻そう。

「何かの式」の部分には3つの式が組み込まれていることに気付いたかな？

１つ目は

```php
$i = 1;
```

２つ目は

```php
$i <= 10;
```

３つ目は

```php
$i++;
```

上記、3つの式で成り立っているんだ。それぞれちゃんと意味がある。それを説明していくよ。

最初の式「$i = 1;」の部分は繰り返しが始まる前に1どだけ実行されるんだ。少し難しく言うと「ループ開始時に無条件に 評価(実行)される」という感じだね。上の例だとループが開始される前に$iという変数を初期化（1に設定する）という処理を行っていることになるね。

次の式「$i <= 10;」の部分は各繰り返し（繰り返し1回毎）の開始前に式が条件に一致しているかしていないか判定（評価）を行い、trueであれば繰り返しを継続、falseであれば繰り返し処理を終わらせるんだ。先の例だと$iが10より小さい場合はtrueなので、「$iが10以上になるまで処理を中断せずに行う」という意味になるね。

最後の式「$i++;」の部分は各繰り返し（繰り返し1回毎）の最後に実行される式になる。これは非常にシンプルで{}内の処理が終わった後に実行される式と覚えよう。先の例だとecho $iした後に$iに1を加算（インクリメント）しているんだね。

ここまでの流れを整理すると、先の基本パターンでは「$iを初期化する」→「$iが10以上か」→「（10未満なら継続、10以上なら終了）」→「echo $i;を実行」→「$iに1を加算」→「$iが10以上か」→「（10未満なら継続、10以上なら終了）」→「echo $i;を実行」→「$iに1を加算」......という形になる。同じことを条件に一致している間、実行する。それがfor文と覚えよう:)

そしてswitch文と同じようにbreak;で処理を中断させることもできるんだ。通常はforの中に書いた条件に一致している間は処理を継続させるんだけど途中で条件を変える必要のあるケースがある。そういう場合に利用されるんだ。あまり使わないけどね。

### foreach

Branch：[section4-2](https://github.com/yoshida-san/php-study/tree/section4-2 "section4-2")

foreachも基本的にはforと同じ繰り返しで処理を行う際に便利な制御構造なんだ。ただ動きは少し違って「配列」に対しての繰り返しが非常に得意なんだ。

```php
$arr = array(1, 2, 3, 4, 5);

// 要素番号を使わない場合
foreach ($arr as $value) {
    echo $value;
}

// 要素番号（key）を使う場合
foreach ($arr as $key => $value) {
    echo $key . "=>" . $value;
}
```

このように配列の最初から最後に対して非常に簡単に繰り返し処理を行うことができる。これをfor文で書こうとすると、

```php
$arr = array(1, 2, 3, 4, 5);
for($i = 0, $size = count($arr); $i < $size; ++$i) {
    echo $arr[$i];
}
```

あまりシンプルではないけれど書けるには書けるんだ。ただ配列のkeyが文字列になるとfor文では書けなくなってしまうんだ。配列の時はforではなく素直にforeachを使うようにしよう。

### while

Branch：[section4-3](https://github.com/yoshida-san/php-study/tree/section4-3 "section4-3")

whileは最も簡単なループと言っていいぐらいに簡単なんだ。早速コードを見てみよう。

```php
<?php
$i = 1;
while ($i <= 10) {
    echo $i;
    $i++;
}
?>
```

何となくfor文に似ているね。基本的にはforと同じ考えで問題ないんだ。()の中に書いてある式がtrueである限りループを継続する、それがwhileなんだ。forと違ってwhileは継続か中断かの式しか()内に書けないところがfor文とは違うところだね。

### do while

Branch：[section4-4](https://github.com/yoshida-san/php-study/tree/section4-4 "section4-4")

do - whileはその名の通りwhile文なんだけどwhile文とは少し違う部分があるんだ。それは繰り返し処理を継続するか中断するかの条件判定を1回処理を行ってから実行するかどうか行う、という点なんだ。whileは最初に条件式の評価をおこなうけどdo - whileは処理の後で評価を行うんだ。言い方を変えれば処理を必ず1回は実行するループ処理、という感じだね。

```php
<?php

// 12345678910と表示される
$i = 1;
do {
    echo $i++;
} while ($i <= 10);

// 0と表示される
$i = 0;
do {
    echo $i;
} while ($i == 0);
?>
```

最初から条件式がfalseになる状態でも必ず1回処理されていることが確認できるね。これがwhileとの違いなんだ。そこまで難しくはないね:)

## Section5 - クラスとメソッドとメンバ変数

ここから少し頭を捻って考える必要が出てくるかもしれない。ただこれはそんなに難しくはないんだ。難しく感じるのは「何故それを使うのか」「どういう時にそれを使うのか」を「これはこういうものだ」より先に覚えようとするから難しく感じるんだ。まずはクラスやメソッド・メンバ変数というのは何なのか、それを覚えていこう。覚えたからといって必ず使わなければならないというわけではないんだ。必要になった時に使えるよう準備をしていこう。

### クラス

クラスと言えば学校を思い出すかな。それともHTMLタグのclassかな、それとも何かのゲームのclassかな。そのどれとも違うしどれとも似ているのがPHPのクラスなんだ。クラスを一言で言うと処理や変数の集合体、という感じかな。全くイメージがわかないと思うけどそれでいいんだよ。クラスの中には処理や変数が内包されている、そう覚えておいて欲しい。

### メソッド

ある一定の処理の塊のことをメソッドと呼ぶよ。例えば数値を入力したら消費税込みの金額で返してくれる処理とか時間を聞いたら返してくれる処理とかね。最も簡単なメソッドはHello worldと出力するメソッドかな。

```php
<?php
// sayHelloというメソッド
function sayHello() {
    echo "Hello world";
}

// メソッドを実行
sayHello();
?>
```

これでsayHelloというメソッドを呼び出すとHello worldと出力されるんだ。とても簡単だね、役には立たないけど。

### メンバ変数

メンバ変数とはそのクラス内でしか使うことができない変数のことなんだ。自クラス用の変数という感じだね。変数はどこからでも参照することができるわけではないんだよ。

### わかったかな？

わかるわけないね。ただ、今の説明は決して間違っているわけではないんだ。まず全体を簡単に伝えたかったんだ。ここから少し詳細な説明をしていくよ。

### ざっくりクラスを作ってみよう

まずは簡単なクラスを作ってみるよ。

```php
<?php
// mkClassという名前のクラス
class mkClass {

    // メンバ変数
    private $int = 100;
    private $str = "Hello ";
    private $bool = true;

    // メソッド
    public function getInt() {
        return $this->int;
    }
    public function getStr($name) {
        return $this->str . $name;
    }
    public function getBool() {
        return $this->bool;
    }
}

// クラスを実体化する（インスタンス生成とも呼ばれる）
$mkClass = new mkClass();

// mkClassのメソッドを呼び出してその結果を出力する
echo $mkClass->getInt();
echo $mkClass->getStr("John Smith");
echo $mkClass->getBool();
?>
```

さて、今度は真面目に説明していくよ。

#### 改めてクラス

先の例で見るとmkClassという名前のクラスを作っているんだ。先にも少し説明したけどクラスは「専用の変数」や「専用の処理」を持ったものになるんだ。先の例で言うと「$int」「$str」「$bool」というmkClass専用の変数と「getInt」「getStr」「getBool」という専用の処理を持っているね。変数や処理は持たずにクラスを作ることもできるけどそれじゃあまり意味はないね。変数やメソッドは別にクラスを作らなくても利用することはできるんだ。

```php
<?php
$int = 100;
$str = "Hello ";
$bool = true;

function getInt() {
    return $int;
}
function getStr($name) {
    return $str . $name;
}
function getBool() {
    return $bool;
}

echo getInt();
echo getStr("John Smith");
echo getBool();
?>
```

こんな感じになる。こっちの方が短くてわかりやすいと思う。なんならこう書いた方がより短くてわかりやすい。

```php
<?php
function getInt() {
    return 100;
}
function getStr($name) {
    return "Hello " . $name;
}
function getBool() {
    return true;
}

echo getInt();
echo getStr("John Smith");
echo getBool();
?>
```

では、何故クラスを使う必要があるのか。使う必要があるから使うんだよ。ただ、ここでは「何故使うのか」は説明しないよ。使う必要が無ければ使わなくて良いんだ。使う必要がある時に使えるよう少しだけ理解して準備をしておくのが目的だからね。

#### 改めてメンバ変数

先程のmkClassのメンバ変数もそうだけど、外部から直接的な操作を受付けさせないようにするんだ（メンバ変数は全て外部からの操作を受け付けないわけではないよ）。これにはとても大事な意味があるんだけどそれはSection10で話をすることにするね。

#### 改めてメソッド

メソッドはある程度の処理をひとまとめにしたもの、と覚えて欲しい。例えばある画像フォルダ内の一覧を作成するプログラムを書いてみるよ。コードの意味はわからなくていいよ。何となくこんなコードがあるんだなーぐらいでOK。

```php
<?php
$dirPath = './';
$listResult = array();
if (is_readable($dirPath) && is_dir($dirPath)) {
    $images = scandir($dirPath);
    foreach ($images as $key => $val) {
        $fullPath = $dirPath . '/' . $val;
        if (file_exists($fullPath) && @exif_imagetype($fullPath)) {
            array_push($listResult, $fullPath);
        }
    }
}
?>
```

これで画像のパス一覧は取得できるんだけど、もしこのコードを1つのプログラムで複数回使うことがあったらどうだろう。今のところ同じプログラムコードを2度3度と書くことになると思うけどそれはあまりよろしくないんだ。何故かと言うとこのプログラムに問題があったり拡張しようとして修正が必要になった場合、同じ修正を何箇所かで行う必要があるんだ。この程度のプログラムであればあまり影響はないのかもしれないけれどこういったことが積もると非表示メンテナンス性の悪いプログラムになってしまう。これを防ぐ意味でもメソッド化は一役買うんだ。早速メソッド化してみよう。

```php
<?php
function getImageList() {
    $dirPath = './';
    $listResult = array();
    if (is_readable($dirPath) && is_dir($dirPath)) {
        $images = scandir($dirPath);
        foreach ($images as $key => $val) {
            $fullPath = $dirPath . '/' . $val;
            if (file_exists($fullPath) && @exif_imagetype($fullPath)) {
                array_push($listResult, $fullPath);
            }
        }
    }
}

// メソッドを呼ぶ
getImageList();
?>
```

メソッドは「function xxxxxxx() {}」という形で作成するんだ。xxxxxxxの部分はメソッドの名前を書いて、{}の中にそのメソッドで行う処理を書いておいて、処理したいところでメソッドを呼ぶんだよ。さっきまでは同じコードを何度も書く形になってしまっていたけどメソッド化をすれば処理を書くのは一度だけで後はメソッドを呼ぶだけでいいんだ。処理を修正する場合も何箇所かで修正するわけじゃなく、1つのメソッドを直すだけでいいからメンテンスも楽になるね。

メソッド化する利点はメンテンス性だけじゃないんだよ。メソッド化することで汎用性も高めることができるんだ。先のコードはphpファイルが存在しているディレクトリの中の画像一覧しか取得できないという少し不便なメソッドなんだ。これを固定ディレクトリではなくディレクトリを指定できるように修正してみよう。

```php
<?php
function getImageList($dirPath) {
    $listResult = array();
    if (is_readable($dirPath) && is_dir($dirPath)) {
        $images = scandir($dirPath);
        foreach ($images as $key => $val) {
            $fullPath = $dirPath . '/' . $val;
            if (file_exists($fullPath) && @exif_imagetype($fullPath)) {
                array_push($listResult, $fullPath);
            }
        }
    }
    return $listResult;
}

// メソッドを呼ぶ
$ret = getImageList('./');
?>
```

メソッド名の後ろの()に変数があるね。これを引数というんだ。引数はメソッドの外から値を受け取って、その受け取った値を使うことができるんだよ。上記の例だと画像一覧を作成するフォルダのパスを指定できるようになったわけだね。これで汎用性が少し上がったね。こうやって汎用性を高めて、似たようなコードは書かないようにしていくのもメンテナンス性を上げる1つの方法なんだ。

最後に戻り値について説明しておくね。さっきから「return $listResult;」という一文がメソッドの最後にいることに気付いたかな。メソッドの呼び方も少し変わっているね。このreturnは引数の逆で値を呼び元に返して上げるという意味なんだ。この場合、getImageListメソッドで作成した一覧（$listResult）を呼び出し元に返しているんだ。

メソッドは「処理をある程度固めて書いておくもの」「保守性やメンテナンス性を上げることができる可能性がある」「引数を設定することができる（複数個可能！）」「処理結果を呼び元に返すことができる（return！）」ができるってことだね。

#### 実体化（インスタンス生成）

クラスの説明は大体終わったけど最後にインスタンスの話をしておくよ。クラスを使う時はそのままじゃ使えないんだ。「new」というワードを使ってクラスを実体化させる必要がある。イメージとしてはクラス自体は「設計図」みたいなものなんだ。ただの紙。車が欲しいと思って車の設計図を買う人はいないよね。プログラムも同じでクラスを実体がさせる必要があるんだ（必ずしもインスタンスを生成しないと動かせないわけではないんだけどね）。ざっくりクラスを作ってみようでも書いたけどnew xxxxxxx();で実体化はできるんだ。xxxxxxxxはクラス名だよ。

大分手抜きで説明してきたけど、これ以上詳しく説明する予定はないし、その必要も無いと思う。これ以上の説明が必要であればきっと君はクラスの必要性やメリットを理解している（または理解しようとしている）だろうし、それらに関する記事はたくさんあるからね。自分で色々調べて手を動かしてみて欲しい。きっとそれが一番の近道でもあり、楽しい道でもあると思うんだ。

## Section6 - スコープ

スコープというのは（主に）変数の参照範囲のことを言うんだ。参照範囲と言ってもあまりピンと来ないと思うんだけど、メソッド内からしか参照できないとかプログラムのどこからでも参照できるとか色々あるんだ。逆に言えば変数は必ず1つのスコープを持っているとも言えるね。覚える必要があるのは3種類、そんなに難しくはないよ。

### ローカルスコープ

文字通りローカルでしか参照できない変数のこと。メソッドの中で定義された変数、と覚えて良いかもしれない。まずは次のコードをみて欲しい。

```php
<?php

function hoge() {
    $piyo = "Piyo";
    echo $piyo;
}

hoge();

// PHP Notice: Undefined variable
echo $piyo;
?>
```

一番最後の行でエラーが起こるんだ。これは「$piyoなんて変数は無いよ」というエラーなんだ。すぐ上にあるのにね。プログラムは人間ほど柔軟ではないからすぐ上にあるからと言って「参照して良い」のか「参照してはいけない」のか判断できないんだ。だからこそ明確なルールが必要なんだ。ローカル（限定的な範囲）でしか参照できないからローカル変数と言うんだね。覚えておこう。例えば$piyoをメソッド以外で使いたい場合はメソッドが$piyoを返すようにしてあげれば問題は解決できる。

```php
<?php

function hoge() {
    $piyo = "Piyo";
    return $piyo;
}

echo hoge();
?>
```

こんな感じ。

プログラムを自分で書く時に一番意識するのがこのローカルスコープかもしれない。それほどに大事なことなんだ。何でもかんでもどこからでも参照できるようにするのは便利な半面、非常に無防備なんだ。時にそれは致命的な不具合を引き起こす可能性を秘めている。コンパクトに必要な時だけ参照できるよう変数は定義していこう。

### グローバルスコープ

ローカルスコープと逆に近い性質を持っていると言ってもいいかな。まずはコードを見てみよう。

```php
<?php
$piyo = 'Piyo';

function hoge() {
    echo $piyo;
}

echo $piyo;
hoge();
?>
```

このプログラムでは8行目のecho $piyoは成功するけど、5行目のecho $piyoでエラーが発生するんだ。何となく使えそうな感じがするんだけどね。$piyoをhogeメソッドから使えるようにするには以下のようにglobalを付けて、「piyoというグローバルスコープを持った変数を使うよ」と宣言する必要がある。

```php
<?php
$piyo = 'Piyo';

function hoge() {
    global $piyo;
    echo $piyo;
}

echo $piyo;
hoge();
?>
```

globalはパスポートみたいなものでそのメソッドの中で使いたければglobalを使って宣言する必要があるんだ。「俺はこのグルーバルスコープを持った変数を使うぞ」ってね。個人的にはグローバルスコープを使うことは殆ど無いと言ってもいいぐらいには使わない。けれど知っておく必要はあると思う。いつどこでグローバルスコープを持った変数と対峙するかわからないからね。

### スーパーグローバル

全ての場所で何の準備も必要とせず使える本当のグローバルスコープ、それがスーパーグローバルなんだ。スーパーグローバルは自分で作ることはできず予め用意されている変数を使うことになる。その変数は次の通り。

* $GLOBALS
* $_SERVER
* $_GET
* $_POST
* $_FILES
* $_COOKIE
* $_SESSION
* $_REQUEST
* $_ENV

$_GLOBALS以外には基本的にPHPが自動的に値を入れたり消したりしてくれるんだ。サーバの情報だったりセッション情報が入っているんだ。プログラマが自分で書き換えて良いのは基本的には$_GLOBALSのみになる。この変数は本当にどこからでも自由に参照できる。すごく便利なように見えるけど地雷のような危険性も孕んでいるから使い方には気を付けよう。一度爆発させてどれだけ危険なものか知った方が良いと思う、まじで。

## Section7 - アクセス権

アクセス権もスコープと同じでその名の通り「アクセスできる範囲」を定義するものなんだ。スコープは変数が対象だっけけれどアクセス権はクラスのメンバ変数やメソッドが対象になるんだ。

### public

publicはその名の通りどこからでもアクセス可能なメソッドやメンバ変数に付与されるんだ。これを修飾子と呼ぶよ。

```php
<?php
// mkClassという名前のクラス
class mkClass {

    // Publicメンバ変数
    public $int = 100;
    // Protectedメンバ変数
    protected $str = "Hello ";
    // Privateメンバ変数
    private $bool = true;

    // Publicメソッド
    public function getInt() {
        // 内部から参照可能
        return $this->int;
    }
    // Protectedメソッド
    protected function getStr($name) {
        // 内部から参照可能
        return $this->str . $name;
    }
    // Privateメソッド
    private function getBool() {
        // 内部から参照可能
        return $this->bool;
    }
}

$mkClass = new mkClass();

// メンバ変数参照
// 実行可能
$mkClass->int = 10000;
echo $mkClass->int;
// 実行不可
$mkClass->str = "Hi ";
echo $mkClass->str;
// 実行不可
$mkClass->bool = false;
echo $mkClass->bool;

// メソッド
// 実行可能
echo $mkClass->getInt();
// 実行不可
echo $mkClass->getStr("John Smith");
// 実行不可
echo $mkClass->getBool();
?>
```

このコードで言えばpublicが付与されているメンバ変数やメソッドはクラスの「外」からも参照可能なのがわかると思う。つまりpublicはクラスの内外問わずどこからでも参照可能、ということなんだ。ただしアクセスするには決まったプログラムのルールがあり、それに準じる必要がある。

### protected

先のコードで外から参照できないものが2つあった。protectedとprivateだね。まずはprotectedについて説明していくよ。protectedは「定義したクラス内」または「継承先クラス内」からのみ実行・参照できるものなんだ。継承先クラスというのはSection11で説明するよ。

### private

privateは定義したクラス内でしか実行・参照できないものになるよ。

### 強さ
縛りの強さは（強い）private > protected > public（弱い）となる。

## Section7.9 - ちょっと一息

ここまでである程度調べ調べPHPは書けるようになったと思う。PHPには標準で便利なメソッドやクラスが用意されているんだけど、それについてはたくさんありすぎるから自分で調べてみて欲しい。プログラムの基本は、その便利なメソッドやクラスを組み合わせて自分の行いたい処理を作成していく形になる。自分で機能をガリガリ作ることはそう多くないのが実情なんだ。実際にプログラムで書くのはif文、for文、それと便利なメソッドの呼び出し、こんなもん。便利なメソッドはGoogleで調べればすぐに見つかるし使い方も詳細に書いてある。ここで説明する必要は一切ないとまで思うよ。

この辺で少し読むのを止めて実際に手を動かしてプログラムを書いてみて欲しい。役に立たないプログラムでいいんだ。書いて動かしてみる。頭でっかちにならずある種の勘を手に入れるために必要なことなんだ。アルゴリズムや理論を武器にしているエンジニアが勘を磨くって不思議な感じもすると思う。勘と言うのはただの当てずっぽうじゃない。経験から来る推測・判断が勘なんだ。これらはプログラムを書く上でもプログラムを追う上でも非常に役に立つ。たくさんのコードを書いて勘を磨いて欲しい。

ついでに言うとここでPHP Study Repositoryは終わりなんだ。PHPの1%は伝えられたと思う。Section8以降は覚えておいたらよりよいコードを書くことができるようになるよ程度のおまけになる。暇があったら読んでみて欲しい。

## Section8 - オブジェクト指向とは

## Section9 - ポリモーフィズム

## Section10 - カプセル化

## Section11 - 継承

## Section12 - インターフェース

## 最後に

おつかれさま。他にも伝えたいことはたくさんあるんだけどそれは君がもっと知りたいと思わないと意味がないし君が覚えたいと思うこととを先に読み取ってここに書くこともできないんだ。僕はエスパーじゃないからね。あまり長々話すのは好きじゃないから最後に1つだけ伝えておきたい。

プログラミングは楽しく自由であるということだ。

これを忘れないで欲しい。

読んでくれてありがとう:)